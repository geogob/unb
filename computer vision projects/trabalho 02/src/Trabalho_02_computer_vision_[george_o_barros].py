# -*- coding: utf-8 -*-
"""Trabalho 02 - Computer Vision [George O. Barros].ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16xjxChuux4_7rZZ3yCbWNGMxvgncumrl

#Trabalho Final de Visão Computacional (2020-1): Classificação de podocitopatia em imagens renais
- Aluno: George Oliveira Barros
- Disciplina: Visão Computacional. PPGI/UnB.
- Dataset: 376 imagens histológicas de glomérulos renais (176 com lesão e 200 sem lesão)
- O dataset não pode ser compartilhado pois faz parte de um conjunto de dados da Fiocruz. Para ser divulgado será necessária a aprovação do comitê de ética da Fundação Osvaldo Cruz (Fiocruz).
- Objetivo: Classificação de imagens de glomérulos renais como imagens "com lesão podocitária" ou "imagens sem lesão podocitária"
- Metodologia: Classificação com diferentes arquiteturas de redes neurais convolucionais e comparação dos resultados das diferentes arquiteturas com transfer learning (Imagenet): Resnet34, Resnet50, Resnet101 e Densenet201.

#LEIA-ME
- Para utilizar os modelos basta carregá-lo e executá-lo com no exemplo a seguir:
- Importe a biblioteca da fast ai 
- Os nomes dos modelos salvos foram: resnet34_model_saved e dense201_model_saved
- Você poderá baixar os modelos salvos e algumas imagens que não fizeram parte do dataset no seguinte link: https://drive.google.com/drive/folders/1rQWknzBQY1M02oXD9vYOIrSnH2wVN3D7?usp=sharing
- Aṕos importar o modelo será possível executá-lo nas imagens desconhecidas
- O dataset não pode ser compatilhado, pois as imagens pertencem a Fiocruz-BA. Para realizar a divulgação das imagens será necessário ser concluído um processo do comitê de ética da instituição.
"""

#Importar FAST AI para usar load_learner

modelo = load_learner('/content/drive/MyDrive/Colab Notebooks/resnet34_model_saved')

modelo.predict('/content/drive/MyDrive/dataset-classification/test/com/image0431.tif.jpg')

"""#Dataset e Dependências"""

#MONTADO AUTOMATICAMENTE QUANDO CARREGO O JUPYTER NOTEBOOK

#from google.colab import drive
#drive.mount('/content/drive')

!pip install fastai --upgrade -q

from fastai.vision.all import *

#from google.colab import drive
#drive.mount('/content/gdrive', force_remount=True)

root_dir = '/content/drive/My Drive/'
base_dir = root_dir + 'dataset-classification/tudo'
path=Path(base_dir)

fields = DataBlock(blocks=(ImageBlock, CategoryBlock),
   get_items=get_image_files,
   get_y=parent_label,
   splitter=RandomSplitter(valid_pct=0.25, seed=42),
   item_tfms=RandomResizedCrop(224, min_scale=0.2),
   batch_tfms=aug_transforms(mult=1.0, do_flip=True, flip_vert=True, max_rotate=20.0, min_zoom=1.0, max_zoom=0.3, max_lighting=0.5, max_warp=0.2, p_affine=0.75, p_lighting=0.75, xtra_tfms=None, size=None, mode='bilinear', pad_mode='reflection', align_corners=True, batch=False, min_scale=1.0))

dls = fields.dataloaders(path)

dls.vocab

dls.train.show_batch(max_n=10, nrows=2)

dls.train.show_batch(max_n=5, nrows=1, unique=True)

"""**Arquiteturas de Redes Rediduais...**

#Resnet34

Iniciando com algumas verificações: fine tunig específico da biblioteca (com apenas uma época pra nova camada adicionada;
"""

learn = cnn_learner(dls, resnet34, metrics=error_rate)
learn.fine_tune(2)

lr_min, lr_steep = learn.lr_find()

print(f"Minimum/10: {lr_min:.2e}, steepest point: {lr_steep:.2e}")

learn = cnn_learner(dls, resnet34, metrics=error_rate)
learn.fine_tune(2, base_lr=3e-3)

learn = cnn_learner(dls, resnet34, metrics=error_rate)
learn.fit_one_cycle(3, 3e-3)

learn.unfreeze()

learn.lr_find()

learn.fit_one_cycle(6, lr_max=1e-4)

"""Treino oficial com transfer learning e ajuste de learning rate. 3 épocas na última camada, descongela a rede inteira e depois treno todas as camdas com o learning rate adequado encontrado nas primeiras verificações"""

learn = cnn_learner(dls, resnet34, metrics=error_rate)
learn.fit_one_cycle(4, 3e-3)
learn.unfreeze()
learn.fit_one_cycle(40, 1e-5) #lr_max=slice(1e-5,1e-3)

learn.recorder.plot_loss()

interp = ClassificationInterpretation.from_learner(learn)
interp.plot_confusion_matrix(dpi=100) #interp.plot_confusion_matrix(figsize=(8,8), dpi=100)

interp.plot_top_losses(5, nrows=1)

interp.print_classification_report()

#learn.export('/content/drive/MyDrive/Colab Notebooks/resnet34_model_saved')

"""#Resnet50"""

#carrega a rede resnet50
learn = cnn_learner(dls, resnet50, metrics=error_rate)

#procura o melhor lr pra treinar a última camada (nova adicionada)
lr_min, lr_steep = learn.lr_find()

#treina a nova camada com o lr adequado encontrado
learn.fit_one_cycle(4,1e-4)

#descongela as demais camadas
learn.unfreeze()

#procura um lr adequado pra treinar a rede inteira
lr_min, lr_steep = learn.lr_find()

learn.fit_one_cycle(20, lr_max=1e-5) #slice(1e-5, 5e-4)

learn.recorder.plot_loss()

interp = ClassificationInterpretation.from_learner(learn)

interp.plot_confusion_matrix()

interp.print_classification_report()

learn.export('/content/drive/MyDrive/Colab Notebooks/resnet50_model_saved')

"""#Resnet101"""

learn = cnn_learner(dls, resnet101, metrics=error_rate)

lr_min, lr_steep = learn.lr_find()

learn.fit_one_cycle(5,3e-3)

learn.unfreeze()

lr_min, lr_steep = learn.lr_find()

learn.fit_one_cycle(20, lr_max=1e-5) #slice(1e-5, 5e-4)

learn.recorder.plot_loss()

interp = ClassificationInterpretation.from_learner(learn)

interp.plot_confusion_matrix()

interp.print_classification_report()

learn.export('/content/drive/MyDrive/Colab Notebooks/resnet101_model_saved')

"""**Arquitetura de rede Densas...**

#Densenet121
"""

learn = cnn_learner(dls, densenet121, metrics=error_rate)

lr_min, lr_steep = learn.lr_find()

learn.fit_one_cycle(5,1e-4)

#descongela as demais camadas
learn.unfreeze()

lr_min, lr_steep = learn.lr_find()

learn.fit_one_cycle(20, lr_max=1e-5) #slice(1e-5, 5e-4)

learn.recorder.plot_loss()

interp = ClassificationInterpretation.from_learner(learn)
interp.plot_confusion_matrix()

interp.print_classification_report()

learn.export('/content/drive/MyDrive/Colab Notebooks/dense121_model_saved')

"""#Densenet201"""

learn = cnn_learner(dls, densenet201, metrics=error_rate)

lr_min, lr_steep = learn.lr_find()

learn.fit_one_cycle(5,1e-4)

learn.unfreeze()

lr_min, lr_steep = learn.lr_find()

learn.fit_one_cycle(20, lr_max=1e-5) #slice(1e-5, 5e-4)

learn.recorder.plot_loss()

interp = ClassificationInterpretation.from_learner(learn)
interp.plot_confusion_matrix()

interp.print_classification_report()

learn.export('/content/drive/MyDrive/Colab Notebooks/dense201_model_saved')